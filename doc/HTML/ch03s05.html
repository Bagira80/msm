<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>eUML2</title><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="Meta State Machine (MSM)"><link rel="up" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Tutorial"><link rel="prev" href="ch03s04.html" title="eUML"><link rel="next" href="ch03s06.html" title="Back-end"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">eUML2</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s04.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;3.&nbsp;Tutorial</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch03s06.html">Next</a></td></tr></table><hr></div><div class="sect1" title="eUML2"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2298"></a>eUML2</h2></div></div></div><p>eUML2 is a C++11 only front-end trying to go even further than eUML on the way
                    to a purely descriptive fsm. It is using the new Boost candidate library
                    <a class="link" href="http://abel.web.elte.hu/mpllibs/metaparse" target="_top"> metaparse</a> from Abel Sinkovics.</p><p>eUML has the disadvantage that the transition table be valid C++ code, which
                    means that whatever appears there (states, events, guards, actions) must be a
                    valid C++ type. This forces us to write a lot of code. With eUML2, a transition
                    is a string, allowing us to be completely free on the syntax and at the same
                    type to only provide types we want to diverge from a default. On the other hand,
                    we now need to be very careful because the compiler cannot protect us from
                    typing mistakes. </p><div class="sect2" title="Shortest state machine ever"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2308"></a>Shortest state machine ever</h3></div></div></div><p>Let us write the shortest state machine ever:</p><pre class="programlisting">struct player_ : public msm::front::state_machine_def&lt;player_&gt;
{
    using initial_state = BOOST_MSM_EUML2_STATE("Empty",player_) ;
    EUML2_STT(
        player_,
        EUML2_STT_CFG(), // will be explained later on
        EUML2_ROW("Empty + open_close              / open_drawer   -&gt; Open"),
        EUML2_ROW("Open  + open_close  [can_close] / close_drawer  -&gt; Empty")
    )
};
typedef msm::back::state_machine&lt;player_&gt; my_fsm;</pre><p>This compiles and even does something. Notice how close the syntax is from
                        eUML. </p><p>We have:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="bold"><strong>source + event -&gt; target</strong></span>: a
                                transition without guard or action</p></li><li class="listitem"><p><span class="bold"><strong>source + event / action -&gt;
                                target</strong></span>: a transition without guard</p></li><li class="listitem"><p><span class="bold"><strong>source + event [guard] -&gt; target</strong></span>:
                                a transition without action</p></li><li class="listitem"><p><span class="bold"><strong>source + event [guard] / action -&gt;
                                    target</strong></span>: a transition with guard and action</p></li><li class="listitem"><p><span class="bold"><strong>source + event</strong></span>: an internal
                                transition without guard or action</p></li><li class="listitem"><p><span class="bold"><strong>source + event / action</strong></span>: an
                                internal transition without guard</p></li><li class="listitem"><p><span class="bold"><strong>source + event [guard]</strong></span>: an
                                internal transition without action</p></li><li class="listitem"><p><span class="bold"><strong>source + event [guard] / action</strong></span>:
                                an internal transition with guard and action</p></li><li class="listitem"><p><span class="bold"><strong>EUML2_INTERNAL("event [guard] /
                                    action")</strong></span> : used within a state, within a
                                EUML2_STT_INTERNAL, an internal transition with guard and
                                action</p></li><li class="listitem"><p><span class="bold"><strong>source -&gt; target</strong></span>: an anonymous
                                transition without guard or action</p></li><li class="listitem"><p><span class="bold"><strong>source / action -&gt; target</strong></span>: an
                                anonymous transition without guard. Other forms with / without
                                guard/action are of course provided</p></li><li class="listitem"><p><span class="bold"><strong>source + * -&gt; target</strong></span>: a
                                transition with any (kleene) event. We now can use '*' for
                                this.</p></li></ul></div></div><div class="sect2" title="Providing behaviour"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2380"></a>Providing behaviour</h3></div></div></div><p>The state machine previously defined compiles and does something but is
                        not useful yet. Let us provide some behaviour to make it do something
                        useful. Let us start with an action. Add the following after the previous
                        code:</p><pre class="programlisting">template&lt;&gt;
template &lt;class Event,class Fsm,class SourceState,class TargetState&gt;
void BOOST_MSM_EUML2_ACTION_IMPL("<span class="bold"><strong>open_drawer</strong></span>",<span class="bold"><strong>player_</strong></span>)::operator()(Event const&amp;, Fsm&amp;, SourceState&amp;, TargetState&amp; )
{
    // do something useful
}</pre><p>Notice how the signature is as always: we get as template parameters an
                        event, fsm, source and target states. The syntax means: we have a default
                        action names "open_drawer" for the front-end player_ (doing nothing) but we
                        want to overwrite it using ours. The same way, we can provide a
                        guard:</p><pre class="programlisting">template&lt;&gt;
template &lt;class Event,class Fsm,class SourceState,class TargetState&gt;
<span class="bold"><strong>bool</strong></span> BOOST_MSM_EUML2_GUARD_IMPL("<span class="bold"><strong>can_close</strong></span>",<span class="bold"><strong>player_</strong></span>)::operator()(Event const&amp;, Fsm&amp;, SourceState&amp;, TargetState&amp; )
{
    // do something useful
    return true;
}</pre><p>Quite often using other front-end we are forced to declare states as empty
                        structures so that we can use them in the transition table. This is no
                        longer necessary so that we now have a function state machine within a few
                        lines of code.</p><p>Also quite often, we are forced to declare states to provide a behaviour,
                        always the same. We can now also avoid this tedious work, which used to make
                        our code less readable. We only need provide a base state and tell the state
                        machine to use it as default:</p><pre class="programlisting">struct <span class="bold"><strong>logging_base_state</strong></span>
{
    template &lt;class Event,class FSM&gt;
    void on_entry(Event const&amp;,FSM&amp; ) {std::cout &lt;&lt; "Entering: " &lt;&lt; name() &lt;&lt; std::endl;}
    template &lt;class Event,class FSM&gt;
    void on_entry(Event const&amp;,FSM&amp; ) {std::cout &lt;&lt; "Exiting: " &lt;&lt; name() &lt;&lt; std::endl;}
    virtual std::string name() const {return "";};
};
struct player_ : public msm::front::state_machine_def&lt;player__,<span class="bold"><strong>logging_base_state</strong></span>&gt;
{
    using initial_state = BOOST_MSM_EUML2_STATE("Empty",player_) ;
    EUML2_STT(
        player_,
        EUML2_STT_CFG(), // will be explained later on
        EUML2_ROW("Empty + open_close              / open_drawer   -&gt; Open"),
        EUML2_ROW("Open  + open_close  [can_close] / close_drawer  -&gt; Empty")
    )
};
typedef msm::back::state_machine&lt;player_&gt; my_fsm;</pre><p>By providing a base state in the front-end definition we ensure all states
                        inherit from it and therefore will use the provided entry and exit
                        behaviour. States also provide a <span class="bold"><strong>name()</strong></span>
                        member so that it is possible to use it for logging.</p><p>Note: to get the best compile time, we need to adjust to our longest
                    string making a transition, for example:</p><pre class="programlisting">#define BOOST_MPL_LIMIT_STRING_SIZE 65
#define MPLLIBS_LIMIT_STRING_SIZE BOOST_MPL_LIMIT_STRING_SIZE
// previous lines to be included before:
#include &lt;boost/msm/front/euml2/euml2.hpp&gt;</pre><p>Please have a look at <a class="link" href="examples/eUML2Minimum.cpp" target="_top">this
                            minimum state machine</a>.</p></div><div class="sect2" title="More grammar capabilities"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2432"></a>More grammar capabilities</h3></div></div></div><p> Like eUML, eUML2 supports UML-like action and guard syntax: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Multiple actions separated by commas: action_1, action_n or
                                    (action_1, action_n)</p></li><li class="listitem"><p>Logical operators for guards (following C++ rules):
                                    &amp;&amp;, ||, !, for example g1 &amp;&amp; g2 || g3, g1
                                    &amp;&amp; !(g2 || !g3)</p></li></ul></div></div><div class="sect2" title="When default behaviour is not enough"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2444"></a>When default behaviour is not enough</h3></div></div></div><p>There are cases where these simple mechanisms to provide behaviour are not
                        sufficient. When we have more complicated states (submachines, entry/exit
                        pseudo states, etc.) and events we want to provide a type and use it. This
                        is where our EUML2_STT_CFG comes of use. We can associate a type to a string
                        and refer to this type within the transition table.</p><pre class="programlisting">struct cd_detected
{
//...
};
struct Playing_ : public msm::front::state_machine_def&lt;Playing_&gt;
{
//...
};
typedef msm::back::state_machine&lt;Playing_&gt; Playing;
struct player_ : public msm::front::state_machine_def&lt;player_&gt;
{
    using initial_state = BOOST_MSM_EUML2_STATE("Empty",player_) ;
    EUML2_STT(
        player_,
        // use predefined cd_detected and Playing and associate them with the provided name
        EUML2_STT_CFG(<span class="bold"><strong>EUML2_STT_USE("cd_detected",cd_detected)</strong></span>,
                      <span class="bold"><strong>EUML2_STT_USE("Playing",Playing)</strong></span>),
        EUML2_ROW("Empty   + <span class="bold"><strong>cd_detected</strong></span> [good_disk &amp;&amp; always_true] / store_cd -&gt; Stopped"),
        EUML2_ROW("<span class="bold"><strong>Playing</strong></span> + stop  / stop_pback -&gt; Stopped"),
    )
};
typedef msm::back::state_machine&lt;player_&gt; my_fsm;</pre><p>This allows us to use submachines, special states, or reuse previously
                        defined types. <a class="link" href="examples/eUML2Minimum.cpp" target="_top">This
                            example</a> is using an already defined submachine.</p></div><div class="sect2" title="Requirements"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2468"></a>Requirements</h3></div></div></div><p>eUML2 is based on metaparse so it must be found within your boost
                        directory. You also need a C++11 compiler. Tested were g++ 4.7 and higher
                        and clang 3.3 and higher. Added compile-times compared to the functor front
                        end are 0.5-1s per transition using clang and up to 2s using g++.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s04.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch03s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">eUML&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Back-end</td></tr></table></div></body></html>